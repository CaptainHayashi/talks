Verifying a Single-Producer Stack
16 Jul 2015
Tags: concurrency sppool safety icap

*Matt*Windsor*
University of York
mbw500@york.ac.uk

Mike Dodds
University of York
mike.dodds@york.ac.uk

# Hi, I'm Matt, and I'm from the High-Integrity Systems Engineering
# research group at the University of York.  I'm currently in my first
# year of a Ph.D supervised by Mike Dodds.
#
# This is the first time I've talked at a workshop, so your feedback is
# greatly appreciated.

* Which stack am I verifying?

# This talk is going to be about one data structure, which is the
# single-producer, multi-consumer pool from Dodds, Haas, and Kirsch's
# paper from POPL this year.

*  

.image sppool.png

* SP pool

Single Producer, multi-consumer pool.

Lock-free, totally ordered, with stack-like interface

Uses a _sentinel_node_ to mark end of pool.

Unsure if linearisable stack, but not needed (bespoke: part of _time-stamped_stack_)

  SPPool {
    Node top;
    Int ID;

    init() { /* ... */ }

    Node insert(Element element) { /* ... */ }
    <Node, Node> getYoungest() { /* ... */ }
    <Bool, Element> remove(Node oldTop, Node node) { /* ... */ }
  }

* Insertion

# init is straightforward, so we don't cover it.

_insert_ inserts to the top, non-atomic node creation, atomic top swap.

.code sppool /INSERT OMIT/,/END INSERT OMIT/

* Removal in two steps

_getYoungest_ non-atomically finds the youngest node…

.code sppool /GETYOUNGEST OMIT/,/END GETYOUNGEST OMIT/


…and _remove_ atomically marks it as _taken_.

.code sppool /REMOVE OMIT/,/END REMOVE OMIT/

* Compression

_insert_ adds nodes, but _remove_ doesn't remove them ⇒ _memory_leak._  Solution:

- After _insert_ or _remove_, non-atomically sweep all taken nodes below current node
- Atomically swing current node's next pointer
- Take taken nodes out of main pool (_spine_)

  Node next = newNode.next;
  while (next->next != next && node.taken) next = next->next;
  newNode.next = next;

_getYoungest_ sweeps only taken nodes between top and youngest node, so:

  CAS(top, oldTop, node);
  if (oldTop != node) oldTop.next = node;

_Assuming_reference_counting_and_ABA_counters_

* Compression
.image fraying0.png

* Compression
.image fraying1.png

* Compression
.image fraying2.png

* Challenges

* The SP pool is a linked list, right?
All the red branches have been moved out and deleted by compression…

.image fraying2.png

* Wrong
Non-atomic traversals → traversals moved out _with_taken_nodes_

.image fraying3.png

* No data-races?
So far the only obvious race (insert-insert) has been mitigated by SP.

But… what about compression-compression?

* Forwards compression data-race
A is inserted; all between A and B taken; compression begins

.image race0.png

* Forwards compression data-race
Compression sweeps to B, which is not taken

.image race1.png

* Forwards compression data-race
_Context_switch_ to removal of B; all between B and C also taken

.image race2.png

* Forwards compression data-race
_Context_switch_ to removal of A; new compression run sweeps to C

.image race3.png

* Forwards compression data-race
If new run updates pointer first…

.image race4.png

* Forwards compression data-race
…part of it is undone by old run when it resumes

.image race5.png

(Also a similar backwards-compression race with insertion!)

* Harmless data-races

Able to show that these data races don't violate invariants

- such as all non-taken nodes being on spine, no cycles, etc.
- These races only undo some compression: unwanted, but _harmless._
- Removing them wasteful?

* What am I proving, and how?

* To prove:

_Memory_safety_ and consistency of the SP pool…

- Next-pointer order is subset of insertion order
- Each node has one, and only one, next pointer
- Sentinel is the only node to point to itself
- Each node must have a path to the sentinel
- Only the spine can have non-taken nodes
- No node can be both taken and non-taken
- Methods adhere to _weak_ preconditions and postconditions

…using the _iCAP_ concurrent separation logic

_Not_linearisability_
—intermediate step towards it

* iCAP

Higher-order concurrent separation logic based on CAP, RGSep, …, Reynolds.

- Shared state is labelled transition system (protocol)
- Transitions require threads to have (fractional) permission.

*What*must*the*proof*show?*

- _Transition_system_ with atomic actions and states
- _Invariants_ and other predicates used in the proof
- _Stability_ of predicates over atomic actions (insert, remove, compress…)
- _Interpretation_function_ from set-tuples to concrete heaps
- _Proof_outline_ of each method

* The abstract state

States are tuples of sets: < T, N, t, s, _P_, _T_ >

No _separation._  No _framing._

Not a deal breaker, but complicates proof.

SP pool not a good fit for transition systems?: not a finite state machine.

* How to deal with this?

.image fraying3.png

Traversals can be moved off and onto the spine at any point
How do we keep track of invariants (eg. all nodes seen so far are taken)?

* Solution

Use _insertion_order_

Remember that this is a _superset_ of physical order

Can show that all-taken property on physical walk
⇒ property on insertion walk
⇒ monotonic over any compressions over the walk

Our atomic actions need to be weak/general enough to be _stable_ under a constantly changing structure
…for example, the _compression_fork_

* Compression fork

.image compress.png


* What can I conclude?

* Conclusions

Simple code doesn't mean simple proofs.

- Data-races can make things very difficult
- Linearisability not easily shown

iCAP works but could fit better.

- Abstraction is good!, but…
- …no framing, no separation
- proof needs to reason about _all_ interference all the time, so massive stability proofs
- Tree logics?

Proof not yet finished: too informal, probably some bugs.
But results look promising.
