Verifying a Single-Producer Stack
11.50, 16 Jul 2015
Tags: concurrency sppool safety icap

*Matt*Windsor*
University of York
mbw500@york.ac.uk

Mike Dodds
University of York
mike.dodds@york.ac.uk

# Hi, I'm Matt, and I'm from the High-Integrity Systems Engineering
# research group at the University of York.  I'm currently in my first
# year of a Ph.D supervised by Mike Dodds.
#
# This is the first time I've talked at a workshop, so your feedback is
# greatly appreciated.

# So, let's talk about verifying a stack.

*  
.image sppool0.png

# We're going to be looking at the SP pool, which is part of the
# time-stamped stack Mike Dodds, Andreas Haas, and Christoph Kirsch
# discussed at POPL this year.

# On the face of it, the SP pool is a linked list, whose nodes contain
# an element and a next pointer.  However, nodes can also be â€˜takenâ€™,
# which marks them as dead to the algorithm.  We have a top pointer,
# but we also need to know when the list ends.

*  
.image sppool1.png

# This is done with a special node that links back to itself, which we
# term the sentinel node.

*  
.image sppool2.png

# The SP pool is single-producer, with one thread taking the push
# operation.

* Pushing

# Pushing is fairly straightforward, and involves making a node,
# giving it the top pointer, and then assigning it to the SP pool's top.
# We're assuming assignment is atomic here.

Non-atomic node creation, atomic top swap.

.code sppool /INSERT OMIT/,/END INSERT OMIT/

Single-producer means insert can't race with itself.

*  
.image sppool3.png

# The SP pool is multi-consumer, with multiple threads being able to
# pop.  The pop occurs in two stages:

* Popping

Non-atomically find the youngest node (or report empty)â€¦

.code sppool /GETYOUNGEST OMIT/,/END GETYOUNGEST OMIT/

â€¦and atomically mark it as _taken_.

.code sppool /REMOVE OMIT/,/END REMOVE OMIT/

# This wraps up the stack methods of the pool.  So far this looks fairly
# simple and easy to prove, but I wouldn't be talking about it if it
# was!  So, we're not finished.

* Compression

# You might have noticed that our pool has a memory leak in it.

Pushing adds nodes, but popping doesn't remove them â‡’ _memory_leak._
Also a time leak, as we have to traverse all these â€˜deadâ€™ nodes.

.image leak.png

Solution: _atomically_ move pointers past taken nodes
â€” take taken nodes out of main pool (_spine_)

# If we have GC/reference-counting, this should work!

* Forwards compression

Non-atomically sweep all taken nodes below current node, then swing next pointer.

  Node next = newNode.next;
  while (next->next != next && next.taken) next = next->next;
  newNode.next = next;

.image fcom.png

* Backwards compression

_getYoungest_ sweeps only taken nodes between top and youngest node, so:

  CAS(top, oldTop, node);
  if (oldTop != node) oldTop.next = node;

# We assume reference counting and ABA counters here.

.image bcom.png

* Compression
.image fraying0.png

Without compression, we have a trivial linked listâ€¦

* Compression
.image fraying1.png

* Compression
.image fraying2.png

GC âŸ¹ still a linked listâ€¦ right?

# So, if we're doing this, then we still have a linked list, right?
# All these red branches are unused nodes that we're just pulling out of
# the spine, right?

* Compression
Non-atomic traversals â†’ traversals moved out _with_taken_nodes_

.image fraying3.png

* Okâ€¦ but at least there aren't any data-races
So far the only obvious race (insert-insert) has been mitigated by SP.

Butâ€¦ what about compression-compression?

* Forwards compression âˆ¥ Forwards compression
Thread 1 pushes A, starting blue compression.  All between nodes A, B, C taken.
Sweeps to B, which is not taken.

.image race0.png

_Trace:_ *1*push(A);*1*compress-sweep(A,*B)*

* Forwards compression âˆ¥ Forwards compression
_Context_switch_. Thread 2 pops B.
Thread 1 is still waiting to switch A's pointer.

.image race1.png

_Trace:_ 1 push(A); 1 compress-sweep(A, B); *2*pop(B)*

* Forwards compression âˆ¥ Forwards compression
_Context_switch_. Thread 3 pops A.
Thread 3 now starts green compression, which sweeps to C.

.image race2.png

_Trace:_ 1 push(A); 1 compress-sweep(A, B); 2 pop(B); *3*pop(A);*3*compress-sweep(A,*C)*

* Forwards compression âˆ¥ Forwards compression
_Context_switch_.
If thread 3 updates pointer firstâ€¦

.image race3.png

_Trace:_ 1 push(A); 1 compress-sweep(A, B); 2 pop(B); 3 pop(A); 3 compress-sweep(A, C);
*3*compress-update(A,*C)*

* Forwards compression âˆ¥ Forwards compression
â€¦part of it is undone by thread 1 when it resumes.
(Also a similar backwards-compression race with insertion!)

.image race4.png

_Trace:_ 1 push(A); 1 compress-sweep(A, B); 2 pop(B); 3 pop(A); 3 compress-sweep(A, C);
3 compress-update(A, C); *1*compress-update(A,*B)*

* Can we show that these don't violate well-formedness invariants?

- All non-taken nodes being on spine, no cycles, etc.
- These races only undo some compression: unwanted, but _harmless._
- Removing them wasteful?

In other words, can we prove _memory_safety_of_the_compressed_SP_pool?_

We want a _framework_ for reasoning about this.

* iCAP

Higher-order concurrent separation logic based on CAP, RGSep, â€¦, Reynolds.

- Shared state is labelled transition system (protocol)
- Transitions (atomic actions) guarded by fractional permissions â†’ single-producer

Let's see what (part of) the transition system looks likeâ€¦

# Next-pointer order is subset of insertion order
# Each node has one, and only one, next pointer
# Sentinel is the only node to point to itself
# Each node must have a path to the sentinel
# Only the spine can have non-taken nodes
# No node can be both taken and non-taken
# Methods adhere to _weak_ preconditions and postconditions


* The abstract state
Each state is a _6-tuple_ of nodes and _sets_ of nodes:

.image tuple0.png

* The abstract state
Each state is a _6-tuple_ of nodes and _sets_ of nodes:

.image tuple1.png
# We have the sets of taken and non-taken nodesâ€¦

* The abstract state
Each state is a _6-tuple_ of nodes and _sets_ of nodes:

.image tuple2.png
# â€¦the top and sentinel nodes, which must be in N union Tâ€¦

* The abstract state
Each state is a _6-tuple_ of nodes and _sets_ of nodes:

.image tuple3.png
# â€¦and two sets of pointers as ordered set pairs, one of which is the
# literal physical next pointer set that can be closed over to make a
# partial physical order, and the other is added to every
# time a node is inserted, and can be used to make a total insertion
# order.

â‰¤ğ“Ÿ â‰œ reflexive transitive closure of ğ“Ÿ
â€”_physical_order_
â‰¤ğ“£ â‰œ reflexive transitive closure of ğ“£
â€”_temporal_(insertion)_order_

* The abstract state is a monolithic tuple
.image framing.png
No _separation._  No _framing._

Actions affect only one or two nodes, but we have to reason about the _whole_pool_.

# Not a deal breaker, but complicates proof.
# SP pool not a good fit for transition systems?: not a finite state machine.

* What does the proof look like?

Invariants/transitions must be general enough to cope with a constantly shifting pool

.image fraying3.png

Let's look at an exampleâ€¦

* Atomic action for forwards compression

*Forwards*compression*of*a*from*b*to*c:*
âŸ¨N, T, t, s, ğ“Ÿ âŠ {(a, b)}, ğ“£âŸ© âˆ§ a >ğ“£ c âˆ§ allTaken(b, c, T, ğ“Ÿ, ğ“£) âŸ¿ âŸ¨N, T, t, s, ğ“Ÿ âŠ {(a, c)}, ğ“£âŸ©

# Compression need not be between two points on the same branch
# â€¦but both sides must be _taken_

.image compress.png

How to show both sides are taken?  That the compression can't make cycles?

* Atomic action for forwards compression

.image compress2.png

# If we apply the insertion order here, then we can simply say that

â‰¤ğ“Ÿ âŠ† â‰¤ğ“£, â‰¤ğ“£ total, and â‰¤ğ“£ monotonic; compression preserves _illusion_ that â‰¤ğ“Ÿ = â‰¤ğ“£

* What can I conclude?

* Conclusions

Simple code doesn't mean simple proofs.

- Data-races can make things very difficult
- Linearisability not easily shown

iCAP works but could fit better.

- Abstraction is good!, butâ€¦
- â€¦no framing, no separation
- proof needs to reason about _all_ interference all the time, so massive stability proofs
- Tree logics?

Proof not yet finished: too informal, probably some bugs.
But results look promising.
